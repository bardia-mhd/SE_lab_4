
# SE_lab_4

##ریفکتور ها

ریفکتور strategy یا replace conditional with polymorphism
اینجا ما switch case داخل کلاس Address را برداشته و به جای آن یک کلاس Strategy تعریف کردیم. با این تغییر در صورتی که در هر کدام از آن caseها بخواهد کاری انجام شود یا کاری اضافه شود تنها در کلاس‌های strategy مربوطه اضافه می‌شود.



ریفکتور seperate query modifier
در این بخش از آنجا که هم مقدار lastDateAddress تغییر می‌کرد و هم برگشت داده می‌شد دو عملکرد را در قالب دو متد جدا کردیم.



ریفکتور self encapsulated field
بر اساس ریفکتور self encapsulated fields دو استفاده‌ی فیلد‌های پرایوت addressType و varType را به صورت getter درآوردیم.



ریفکتور loose coupling
در چندین کلاس این مشکل وجود داشت که ArrayList تعریف شده بود در صورتی که این DIP را نقض می‌کند و هنگامی که می‌خواهیم مقدار دهی کنیم باید تایپ آن مشخص شود.



ریفکتور inline temp
یکی از local temp variableها را که تنها تعریف و بعد استفاده شده بود را به صورت در خط استفاده کردیم.



ریفکتور facade
در کلاس CodeGnerator به سرویس های مختلفی رجوع شده بود این اتفاق در کلاس Parser به سرویس‌های CodeGenerator و Lexical Analysis نیز افتاده بود که آن ها را به یک کلاس مجزای ParserFacade منتقل کردیم که برای اعمال دیزاین پترن Facade است. به منظور اعمال الگو facade برای کلاس main بک کلاس ParserStarterFacade تعریف می‌کنیم که از داخل main آن را صدا بزند.

---

## پرسش‌ها

1. هر یک از مفاهیم زیر را در حد یک خط توضیح دهید.
     - **کد تمیز**: کدی است که قابل فهم، قابل توسعه و قابل تعمیر است، و به نحوی نوشته شده‌است که دیگر برنامه‌نویسان به راحتی می‌توانند آن را بخوانند و با آن کار کنند.
     - **بدهی فنی**: زمانی که به جای انتخاب بهترین و ماندگارترین راه حل برای یک مسئله، راه‌حلی موقتی و سریع‌تر انتخاب می‌شود، و باعث می‌شود در آینده برای تعمیر یا توسعه کد، زمان و هزینه بیشتری صرف شود.
     - **بوی بد**: نشانه‌ها یا الگوهایی در کد که ممکن است نشان‌دهندهٔ مشکلات پنهان یا مسائلی باشند که ممکن است در آینده به مشکلات بزرگتری منجر شوند و نیاز به بازنویسی یا تعمیر داشته باشند.

<div dir="rtl">
     
2. طبق دسته‌بندی وب‌سایت refactoring.guru، بوهای بد کد به پنج دسته تقسیم می‌شوند. در مورد هر کدام از این پنج دسته توضیح مختصری دهید.
     - دسته **Bloaters**: این دسته شامل کدهایی است که با گذشت زمان بزرگتر و حجیم‌تر می‌شوند و به تدریج سخت‌تر می‌شود با آنها کار کرد. به عبارت دیگر، این بوها نتیجهٔ نادیده گرفتن مشکلات کوچک در طول زمان هستند. مثال‌هایی از آن عبارتند از: طویل شدن توابع، کلاس‌های بزرگ، و پارامترهای زیاد.
     - دسته **Object-Orientation Abusers**: این دسته شامل مسائلی است که زمانی رخ می‌دهد که قوانین و مفاهیم شیءگرایی به درستی رعایت نمی‌شوند. مثال‌هایی از آن عبارتند از: استفاده از وراثت به جای ترکیب، یا مواردی که یک کلاس بیش از یک وظیفه را انجام می‌دهد.
     - دسته **Change Preventers**: این دسته شامل آن کدهایی است که هر زمان می‌خواهید یک تغییر کوچک در برنامه ایجاد کنید، مجبور می‌شوید که تغییرات زیادی در قسمت‌های دیگر انجام دهید.
     - دسته **Dispensables**: این دسته به بخش‌هایی از کد اشاره دارد که در واقع نیازی به آنها نیست. این قسمت‌ها ممکن است به شکل کدهای مرده، توابع بی‌استفاده، یا کلاس‌های زائد در برنامه وجود داشته باشند.
         
     - دسته **Couplers**: این دسته به کدهایی اشاره دارد که به شدت به قسمت‌های دیگر برنامه وابسته هستند، به طوری که هر تغییر در یک قسمت ممکن است تأثیرات زیادی در قسمت‌های دیگر داشته باشد.

</div>



3. یکی از انواع بوهای بد، Lazy Class است.
    - این بوی بد در کدام یک از دسته‌بندی‌های پنج‌گانه قرار می‌گیرد?<br>
    **Lazy Class** یا «کلاس تنبل»، در دسته‌بندی **Dispensables (غیرضروری‌ها)** قرار می‌گیرد. وقتی یک کلاس به حدی کم استفاده می‌شود که به نظر نمی‌رسد ارزش حفظ آن را داشته باشد، این بو در کد ایجاد می‌شود.
    - برای برطرف‌کردن این بو، استفاده از کدام بازآرایی‌ها پیشنهاد می‌شود?<br>
    برای برطرف کردن این بوی بد، بازآرایی‌های زیر می‌تواند مفید باشد:
         1. بازآرایی **Inline Class**: اگر کلاسی  تنبل است و وظیفهٔ خاصی را انجام نمی‌دهد، می‌توانیم اعضای آن کلاس را در کلاس دیگری جا به جا کنیم و کلاس اصلی را حذف کنیم.
         2. بازآرایی **Collapse Hierarchy**: اگر یک زیرکلاس یا سوپرکلاس به حدی تنبل شده باشد که نیازی به وجود آن نباشد، می‌توانیم آن را با کلاس دیگری ادغام کنیم.
    - در چه مواقعی باید این بو را نادیده گرفت؟<br>
    در مواقعی که تصور می‌شود کلاس در آینده ممکن است ویژگی‌ها یا کارکردهای جدیدی به خود اضافه کند یا مواقعی که وجود یک کلاس، حتی با وظایف محدود، به دلیل معماری نرم‌افزار یا اهداف مشخصی معنی‌دار است، ممکن است تصمیم بگیریم که این بوی بد را نادیده بگیریم. در واقع، همیشه باید توجه داشت که معیارهای بازآرایی باید با توجه به نیازهای پروژه اعمال شوند.
